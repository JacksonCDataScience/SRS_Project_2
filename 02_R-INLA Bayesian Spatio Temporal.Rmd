---
title: |
  <center> Statistical Research Skill </center>
  <center> Group 6 </center>
subtitle: School of Mathematics, University of Edinburgh
output:
  pdf_document: default
  html_document:
    df_print: paged
---

### Model Structure

The Bayesian hierarchical spatio-temporal (BHST) model is specified as:

$$
y_{s,t}
=
\mu
+
u_s
+
\delta(t)
+
\alpha_{\text{month}(t)}
+
\gamma_t
+
\epsilon_{s,t},
$$

where:

- $y_{s,t}$ denotes the observed temperature at spatial location $s$ and time $t$.


**Model Components**

- **Global mean ($\mu$)**  
  Represents the overall average temperature level across all spatial locations and time periods.

- **Spatial structured effect ($u_s$)**  
  Models spatial dependence between neighbouring grid cells.  
  This component is specified using a Conditional Autoregressive (CAR) or BYM2 prior, allowing geographically nearby locations to exhibit similar temperature patterns.

- **Smooth temporal trend ($\delta(t)$)**  
  Captures long-term climate evolution over time.  
  A second-order random walk (RW2) prior is used to allow a flexible, smooth nonlinear trend without imposing a strict linear structure.

- **Seasonal component ($\alpha_{\text{month}(t)}$)**  
  Represents the repeating annual cycle in temperature.  
  This is modelled as a 12-level categorical effect corresponding to the month of the year, typically constrained to sum to zero for identifiability.

- **Temporal autocorrelation ($\gamma_t$)**  
  Accounts for short-term persistence between consecutive observations.  
  This component is modelled using an autoregressive process of order one (AR(1)).

- **Observation error ($\epsilon_{s,t}$)**  
  Represents unexplained variability, assumed to follow:

$$
\epsilon_{s,t} \sim \mathcal{N}(0, \sigma^2).
$$


The model decomposes temperature variability into: spatial structure, long-term temporal trend, seasonal periodic effects, short-term temporal dependence, and residual noise.

#### R Code
```{r}
# ============================================================
# Model:
#   y_{s,t} = mu + u_s (BYM2) + delta(t) (RW2) + alpha_month(t) + 
#             gamma_t (AR1) + eps
# ============================================================
# ---------- 0) Packages ----------
library(terra)
library(sf)
library(dplyr)
library(tidyr)
library(lubridate)
library(INLA)

# ---------- 1) Read Scotland-only NetCDF from python process ----------
r_var <- rast("ds_scotland.nc", subds = "anom")  # loads only anomaly tmp data

# Inspect whatâ€™s inside
print(r_var) # names(r_var): to see layer names

# ---------- 2) Dates from NetCDF time metadata ----------
dates <- terra::time(r_var)
if (is.null(dates)) {
  stop("No time metadata found in ds_scotland.nc. Print names(r_var) and we can parse dates safely.")
}
dates <- as.Date(dates)

layer_names <- names(r_var)
T <- nlyr(r_var)

# ---------- 3) Wide dataframe (lon/lat + layers) ----------
# na.rm=TRUE drops NA cells (outside Scotland) for each layer automatically
df_wide <- as.data.frame(r_var, xy = TRUE, na.rm = TRUE) |>
  rename(lon = x, lat = y)

# ---------- 4) Long dataframe (one row per cell-month) ----------
df_long <- df_wide |>
  pivot_longer(
    cols = -c(lon, lat),
    names_to = "layer",
    values_to = "temp"
  ) |>
  mutate(
    t = match(layer, layer_names),
    date = dates[t],
    year = year(date),
    month = month(date),
    cell = interaction(round(lon, 4), round(lat, 4), drop = TRUE)  # stable cell key
  ) |>
  select(lon, lat, cell, t, date, year, month, temp) |>
  filter(!is.na(temp))

cat("Rows N =", nrow(df_long), "\n")
cat("Time points T =", length(unique(df_long$t)), "\n")
cat("Cells S =", length(unique(df_long$cell)), "\n")

# ---------- 5) Build spatial cell map + rook adjacency ----------
# Round coordinates to avoid floating mismatches in indexing
xy_map <- df_long |>
  distinct(cell, lon, lat) |>
  mutate(
    lon_r = round(lon, 4),
    lat_r = round(lat, 4)
  )

xs <- sort(unique(xy_map$lon_r))
ys <- sort(unique(xy_map$lat_r))

xy_map <- xy_map |>
  mutate(
    ix = match(lon_r, xs),
    iy = match(lat_r, ys)
  ) |>
  arrange(ix, iy) |>
  mutate(cell_id = row_number())

S <- nrow(xy_map)

# Lookup (ix,iy) -> cell_id
lookup <- setNames(xy_map$cell_id, paste(xy_map$ix, xy_map$iy, sep=","))

neighbors <- vector("list", S)
for (k in seq_len(S)) {
  ix <- xy_map$ix[k]
  iy <- xy_map$iy[k]
  cand <- c(paste(ix+1, iy, sep=","),
            paste(ix-1, iy, sep=","),
            paste(ix, iy+1, sep=","),
            paste(ix, iy-1, sep=","))
  nb <- lookup[cand]
  neighbors[[k]] <- as.integer(nb[!is.na(nb)])
}

cat("Zero-neighbour cells:", sum(sapply(neighbors, length) == 0), "\n")
cat("Neighbour count summary:\n")
print(summary(sapply(neighbors, length)))

# ---------- 6) Write INLA adjacency file manually + read graph ----------
adj_file <- tempfile(fileext = ".adj")
con <- file(adj_file, open = "w")

# First line: number of nodes
writeLines(as.character(S), con)

# Each subsequent line: node_id n_neighbors neighbor1 neighbor2 ...
for (i in seq_len(S)) {
  nb_i <- neighbors[[i]]
  line <- paste(
    i,
    length(nb_i),
    if (length(nb_i) > 0) paste(nb_i, collapse = " ") else ""
  )
  writeLines(line, con)
}
close(con)

g <- INLA::inla.read.graph(adj_file)

# ---------- 7) Prepare INLA modelling data ----------
df_inla <- df_long |>
  left_join(xy_map |> select(cell, cell_id), by = "cell") |>
  mutate(
    month_id = month,  # 1..12
    time_rw  = t,      # RW2 index
    time_ar  = t       # AR(1) index
  )

# ---------- 8) Fit BHST model in INLA ----------
formula <- temp ~ 1 +
  f(month_id, model = "iid", constr = TRUE) +     # seasonality (sum-to-zero)
  f(time_rw,  model = "rw2", constr = TRUE) +     # smooth long-term trend
  f(time_ar,  model = "ar1") +                    # short-term persistence
  f(cell_id,  model = "bym2", graph = g)          # spatial structured + unstructured

fit <- inla(
  formula,
  family = "gaussian",
  data = df_inla,
  control.predictor = list(compute = TRUE),
  control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE)
)

print(summary(fit))
cat("DIC:", fit$dic$dic, "\n")
cat("WAIC:", fit$waic$waic, "\n")

# ---------- 9) Plot posterior mean components ----------
# RW2 trend
trend_post <- fit$summary.random$time_rw
plot(dates, trend_post$mean, type = "l",
     xlab = "Date", ylab = "RW2 trend (posterior mean)",
     main = "Smooth long-term trend (RW2)")

# Seasonality (month effects)
seas_post <- fit$summary.random$month_id
plot(1:12, seas_post$mean, type = "b",
     xlab = "Month", ylab = "Seasonal effect (posterior mean)",
     main = "Seasonality (month-of-year)")

# Spatial effect (BYM2): plot on lon/lat points
sp_post <- fit$summary.random$cell_id

sp_df <- data.frame(
  cell_id = as.integer(rownames(sp_post)),
  spatial_mean = sp_post$mean
)

xy_plot <- xy_map %>%
  left_join(sp_df, by = "cell_id")

cols <- heat.colors(100)
plot(xy_plot$lon, xy_plot$lat,
     col = cols[rank(xy_plot$spatial_mean, ties.method="first")],
     pch = 15, asp = 1,
     xlab = "Longitude", ylab = "Latitude",
     main = "Posterior mean spatial effect (BYM2)")
```






