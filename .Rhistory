# ============================================================
# Model:
#   y_{s,t} = mu + u_s (BYM2) + delta(t) (RW2) + alpha_month(t) +
#             gamma_t (AR1) + eps
# ============================================================
# ---------- 0) Packages ----------
library(terra)
library(sf)
library(dplyr)
library(tidyr)
library(lubridate)
library(INLA)
# ---------- 1) Read Scotland-only NetCDF from python process ----------
r_all <- rast("ds_scotland.nc")  # loads all variables/layers from the NetCDF
# Inspect what’s inside
print(r_all)
names(r_all)  # to see layer names
# ---------- 3) Dates from NetCDF time metadata ----------
dates <- terra::time(r_var)
r_var <- r_all[["anom"]] # use anomaly data only
# Inspect what’s inside
print(r_all) # names(r_all): to see layer names
r_var <- r_all[["anom"]] # use anomaly data only
sds("ds_scotland.nc")
# ---------- 1) Read Scotland-only NetCDF from python process ----------
r_var <- rast("ds_scotland.nc", subds = "anom")  # loads only anomaly tmp data
# Inspect what’s inside
print(r_var) # names(r_var): to see layer names
# ---------- 3) Dates from NetCDF time metadata ----------
dates <- terra::time(r_var)
if (is.null(dates)) {
stop("No time metadata found in ds_scotland.nc. Print names(r_var) and we can parse dates safely.")
}
dates <- as.Date(dates)
layer_names <- names(r_var)
T <- nlyr(r_var)
# ---------- 4) Wide dataframe (lon/lat + layers) ----------
# na.rm=TRUE drops NA cells (outside Scotland) for each layer automatically
df_wide <- as.data.frame(r_var, xy = TRUE, na.rm = TRUE) |>
rename(lon = x, lat = y)
# ---------- 5) Long dataframe (one row per cell-month) ----------
df_long <- df_wide |>
pivot_longer(
cols = -c(lon, lat),
names_to = "layer",
values_to = "temp"
) |>
mutate(
t = match(layer, layer_names),
date = dates[t],
year = year(date),
month = month(date),
cell = interaction(round(lon, 4), round(lat, 4), drop = TRUE)  # stable cell key
) |>
select(lon, lat, cell, t, date, year, month, temp) |>
filter(!is.na(temp))
cat("Rows N =", nrow(df_long), "\n")
cat("Time points T =", length(unique(df_long$t)), "\n")
cat("Cells S =", length(unique(df_long$cell)), "\n")
# ---------- 6) Build spatial cell map + rook adjacency ----------
# Round coordinates to avoid floating mismatches in indexing
xy_map <- df_long |>
distinct(cell, lon, lat) |>
mutate(
lon_r = round(lon, 4),
lat_r = round(lat, 4)
)
xs <- sort(unique(xy_map$lon_r))
ys <- sort(unique(xy_map$lat_r))
xy_map <- xy_map |>
mutate(
ix = match(lon_r, xs),
iy = match(lat_r, ys)
) |>
arrange(ix, iy) |>
mutate(cell_id = row_number())
S <- nrow(xy_map)
# Lookup (ix,iy) -> cell_id
lookup <- setNames(xy_map$cell_id, paste(xy_map$ix, xy_map$iy, sep=","))
neighbors <- vector("list", S)
for (k in seq_len(S)) {
ix <- xy_map$ix[k]
iy <- xy_map$iy[k]
cand <- c(paste(ix+1, iy, sep=","),
paste(ix-1, iy, sep=","),
paste(ix, iy+1, sep=","),
paste(ix, iy-1, sep=","))
nb <- lookup[cand]
neighbors[[k]] <- as.integer(nb[!is.na(nb)])
}
cat("Zero-neighbour cells:", sum(sapply(neighbors, length) == 0), "\n")
cat("Neighbour count summary:\n")
print(summary(sapply(neighbors, length)))
# ---------- 7) Write INLA adjacency file manually + read graph ----------
adj_file <- tempfile(fileext = ".adj")
con <- file(adj_file, open = "w")
# First line: number of nodes
writeLines(as.character(S), con)
# Each subsequent line: node_id n_neighbors neighbor1 neighbor2 ...
for (i in seq_len(S)) {
nb_i <- neighbors[[i]]
line <- paste(
i,
length(nb_i),
if (length(nb_i) > 0) paste(nb_i, collapse = " ") else ""
)
writeLines(line, con)
}
close(con)
g <- INLA::inla.read.graph(adj_file)
# ---------- 8) Prepare INLA modelling data ----------
df_inla <- df_long |>
left_join(xy_map |> select(cell, cell_id), by = "cell") |>
mutate(
month_id = month,  # 1..12
time_rw  = t,      # RW2 index
time_ar  = t       # AR(1) index
)
# ---------- 9) Fit BHST model in INLA ----------
formula <- temp ~ 1 +
f(month_id, model = "iid", constr = TRUE) +     # seasonality (sum-to-zero)
f(time_rw,  model = "rw2", constr = TRUE) +     # smooth long-term trend
f(time_ar,  model = "ar1") +                    # short-term persistence
f(cell_id,  model = "bym2", graph = g)          # spatial structured + unstructured
fit <- inla(
formula,
family = "gaussian",
data = df_inla,
control.predictor = list(compute = TRUE),
control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE)
)
print(summary(fit))
cat("DIC:", fit$dic$dic, "\n")
cat("WAIC:", fit$waic$waic, "\n")
# ---------- 10) Plot posterior mean components ----------
# RW2 trend
trend_post <- fit$summary.random$time_rw
plot(dates, trend_post$mean, type = "l",
xlab = "Date", ylab = "RW2 trend (posterior mean)",
main = "Smooth long-term trend (RW2)")
# Seasonality (month effects)
seas_post <- fit$summary.random$month_id
plot(1:12, seas_post$mean, type = "b",
xlab = "Month", ylab = "Seasonal effect (posterior mean)",
main = "Seasonality (month-of-year)")
axis(1, at = 1:12)
# ---------- 10) Plot posterior mean components ----------
# RW2 trend
trend_post <- fit$summary.random$time_rw
stopifnot(!is.null(trend_post))
y_trend <- as.numeric(trend_post$mean)
plot(dates, y_trend, type = "l",
xlab = "Date", ylab = "RW2 trend (posterior mean)",
main = "Smooth long-term trend (RW2)")
# ---------- 10) Plot posterior mean components ----------
# RW2 trend
trend_post <- fit$summary.random$time_rw
plot(dates, trend_post$mean, type = "l",
xlab = "Date", ylab = "RW2 trend (posterior mean)",
main = "Smooth long-term trend (RW2)")
# Seasonality (month effects)
seas_post <- fit$summary.random$month_id
plot(1:12, seas_post$mean, type = "b",
xlab = "Month", ylab = "Seasonal effect (posterior mean)",
main = "Seasonality (month-of-year)")
axis(1, at = 1:12)
# Seasonality (month effects)
seas_post <- fit$summary.random$month_id
plot(1:12, seas_post$mean, type = "b",
xlab = "Month", ylab = "Seasonal effect (posterior mean)",
main = "Seasonality (month-of-year)")
# Seasonality (month effects)
plot(1:12, seas_post$mean, type = "b",
xlab = "Month", ylab = "Seasonal effect (posterior mean)",
main = "Seasonality (month-of-year)",
xaxt = "n")   # suppress default axis
axis(1, at = 1:12, labels = 1:12)
# Seasonality (month effects)
seas_post <- fit$summary.random$month_id
plot(1:12, seas_post$mean, type = "b",
xlab = "Month", ylab = "Seasonal effect (posterior mean)",
main = "Seasonality (month-of-year)")
# Spatial effect (BYM2): plot on lon/lat points
sp_post <- fit$summary.random$cell_id
xy_plot <- xy_map |>
mutate(spatial_mean = sp_post$mean)
# Spatial effect (BYM2): plot on lon/lat points
sp_post <- fit$summary.random$cell_id
stopifnot(!is.null(sp_post))
xy_plot <- xy_map |>
mutate(spatial_mean = as.numeric(sp_post$mean))
# Seasonality (month effects)
seas_post <- fit$summary.random$month_id
plot(1:12, seas_post$mean, type = "b",
xlab = "Month", ylab = "Seasonal effect (posterior mean)",
main = "Seasonality (month-of-year)")
# Spatial effect (BYM2): plot on lon/lat points
sp_post <- fit$summary.random$cell_id
xy_plot <- xy_map |>
mutate(spatial_mean = sp_post$mean)
sp_post <- fit$summary.random$cell_id
str(sp_post)
head(sp_post)
nrow(sp_post)
# Spatial effect (BYM2): plot on lon/lat points
sp_post <- fit$summary.random$cell_id
sp_df <- data.frame(
cell_id = as.integer(rownames(sp_post)),
spatial_mean = sp_post$mean
)
xy_plot <- xy_map %>%
left_join(sp_df, by = "cell_id")
cols <- heat.colors(100)
plot(xy_plot$lon, xy_plot$lat,
col = cols[rank(xy_plot$spatial_mean, ties.method="first")],
pch = 15, asp = 1,
xlab = "Longitude", ylab = "Latitude",
main = "Posterior mean spatial effect (BYM2)")
# Spatial effect (BYM2): plot on lon/lat points
sp_post <- fit$summary.random$cell_id
sp_df <- data.frame(
cell_id = as.integer(rownames(sp_post)),
spatial_mean = sp_post$mean
) %>%
group_by(cell_id) %>%
summarise(spatial_mean = mean(spatial_mean), .groups="drop")
xy_plot <- xy_map %>% left_join(sp_df, by="cell_id")
cols <- heat.colors(100)
plot(xy_plot$lon, xy_plot$lat,
col = cols[rank(xy_plot$spatial_mean, ties.method="first")],
pch = 15, asp = 1,
xlab = "Longitude", ylab = "Latitude",
main = "Posterior mean spatial effect (BYM2)")
# Spatial effect (BYM2): plot on lon/lat points
sp_post <- fit$summary.random$cell_id
sp_df <- data.frame(
cell_id = as.integer(rownames(sp_post)),
spatial_mean = sp_post$mean
)
xy_plot <- xy_map %>%
left_join(sp_df, by = "cell_id")
cols <- heat.colors(100)
plot(xy_plot$lon, xy_plot$lat,
col = cols[rank(xy_plot$spatial_mean, ties.method="first")],
pch = 15, asp = 1,
xlab = "Longitude", ylab = "Latitude",
main = "Posterior mean spatial effect (BYM2)")
install.packages("tinytex")
